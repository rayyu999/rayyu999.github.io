[{"categories":["Papers"],"content":"Liehuang Zhu, Xiangyun Tang, Meng Shen, Jie Zhang, Xiaojiang Du IEEE Internet of Things Journal https://arxiv.org/abs/2009.09691 摘要：在智能城市的开发中，机器学习(ML)越来越受欢迎，它欣赏从各种物联网(IoT)设备生成的高质量训练数据集，这自然引发了人们对此类设置中可以提供的隐私保障的质疑。聚合场景中的隐私保护ML训练使模型需求者能够使用从物联网设备收集的敏感物联网数据安全地训练ML模型。现有的解决方案一般都是服务器辅助的，无法应对服务器之间或服务器与数据所有者之间的共谋威胁，与物联网的微妙环境不匹配。提出了一种基于部分同态加密的构建块库的隐私保护ML训练框架HEDA，该框架能够在不依赖不可信服务器的情况下，针对聚合场景构建多个隐私保护的ML训练协议，并在合谋情况下维护安全性。严格的安全性分析表明，所提出的协议能够保护诚实但好奇模型中每个参与者的隐私，并保证大多数合谋情况下的安全性。大量实验验证了HEDA算法的有效性，在保证模型精度的前提下实现了隐私保护的ML训练。 本文贡献： 为了在密文上训练ML模型而没有精度损失，我们设计了一个基于加法同构加密Paillier[42]和乘法同构加密CloudRSA[43]的构建块库。受排列和组合思想的启发，复杂算法可以分解为几个原始操作，在确定了许多ML训练算法的基础上的一组核心操作之后，我们仔细设计了一个支持每个核心操作的构建块库。 为了保证合谋情况下的安全性和满足聚合场景下的安全需求，我们设计了另外两个构件，可以将一个算法的输出转换为另一个算法的输入。所有构建块都以可组合的方式设计，并且同时满足功能性和安全性，其中构建块之间的组合的安全性通过模块顺序组合来确保[44]。 我们实例化了三个隐私保护的ML训练协议：a)LR；b)SVM；c)NB，没有不可信服务器的帮助。据我们所知，我们是第一个在没有任何近似方程的情况下求解隐私保护LR训练中的非线性函数的。 ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:0:0","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"RELATED WORK ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:1:0","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"SYSTEM OVERVIEW ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:2:0","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"System Model 作者设想了一个数据驱动的物联网生态系统，如图1所示，包括物联网设备、物联网数据所有者和模型需求者。 *物联网设备：*它们负责通过无线或有线网络感知和传输有价值的物联网数据。 *数据所有者：*他们从自己域内的物联网设备收集所有物联网数据。 *模型需求者：*它想要在从多个数据所有者收集的数据集上训练ML模型。 物联网设备能够通过4G和WiFi等无线网络感知和传输有价值的物联网数据。这些物联网数据涵盖了智能城市中的各种现实应用，从环境变化到生理状况和个人信息。物联网数据所有者从自己域内的物联网设备收集所有数据。在域中存储和收集物联网数据后，物联网设备将在执行Heda协议期间离线，不再参与模型培训。数据所有者接管物联网设备的后续行为。 本文假设所有参与者都同意Heda去联合训练一个模型，并且每个数据所有者都同意将全局模型发布到服务器。每个数据所有者生成其个人密钥对来加密其数据，模型需求者也持有自己的密钥对用于模型加密。 ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:2:1","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"Threat Model 每个数据所有者可以通过诚实地执行预先设置的协议，尽可能多地了解其他数据所有者的敏感数据和模型需求者的模型。模型需求者诚实地遵守协议，但它试图从他了解的值中尽可能多地推断数据所有者的敏感数据。因此，对于任何参与者，本文都假设它是被动的(或诚实但好奇的)对手[53]，也就是说，它确实遵循协议，但它试图从他们学习的价值观中尽可能多地推断其他参与者的隐私。 所提出的构建块（安全求和除外）处于双方计算设置中，应在诚实但好奇的模型中确保安全。虽然由构建块构建的私有保护ML训练协议是多方协议，其中参与者可以彼此串通以获取更多信息以推断其他参与者的隐私。在本文的解决方案中，最多允许 $(n-1)$ 个数据所有者相互勾结以泄露其他参与者的隐私，最多允许 $(n - 2)$ 数据所有者最多与模型需求者勾结以泄露其他参与者的隐私。请注意，当数据所有者彼此勾结时，他们可以在其联合数据集上计算模型结果。因此，抵御这种极端情况毫无意义。 本文的模型可能会遇到外部攻击者，他们在传输过程中通过互联网窃听或其他方式非法获取数据。而外部对手可以通过使用现有的通用技术（如TSL）建立保密和可信的通道来控制。 ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:2:2","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"BUILDINGBLOCKS BASED ON PARTIAL HOMOMORPHIC ENCRYPTION ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:3:0","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"Design Idea 类似数学公式可以分解为加减乘除的排列组合，ML 训练算法也可以分解为一组核心基本运算。本文就是基于这样的思路设计了一系列安全的计算方法。 ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:3:1","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"Building Blocks for Primitive Operations Building Block 1-4 由于很容易获得安全的加法、减法和乘法，因此本文将它们直接包含在构建块库中。 Pillier 安全加法 Pillier 安全减法 Pillier 明文-密文乘法 Cloud-RSA 密文乘法 根据 Pillier 以及 Cloud-RSA 方案的安全性很容易证明 building blocks 1-4 在半诚实设置下是安全的。 Building Block 5 (Secure Power Function) 假设数据所有者使用他的 Cloud-RSA 公钥加密 $e^\\bold{a}$，并将密文 $[e^\\bold{a}]_R$ 发送给模型需求者。模型需求者有 $\\bold{b} = {b_1, b_2, …, b_d}$，希望获得 $[e^{\\bold{a \\cdot b}}]_R$： $$\\begin{align}\r[e^{\\textbf{a} \\cdot \\textbf{b}}]_R \u0026= [e^{a_1b_1 + a_2b_2 + \\cdots +a_db_d}]_R \\\\\r\u0026= \\prod^d_{i=1}[e^{a_ib_i}]_R = \\prod^d_{i=1}([e^{a_i}]_R)^{b_i} \\tag{1}\r\\end{align}$$\r公式(1)定义了本文的安全幂函数。通过这种方式，模型需求者可以通过 $(\\sum^d_{i=1} b_i + d - 1)$ 次乘法获得 $[e^{\\bold{a \\cdot b}}]_R$。 Building Block 6 (Secure Summation) 有 $n$ 个数据拥有者，本文的安全聚合方法可以保证在不泄露各个数据拥有者隐私的情况以及各个数据拥有者密钥不同的情况下完成聚合： ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:3:2","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"Building Blocks for Conversion 由于Heda涉及两个不同的密码系统和多个参与者，使用上述构建块是不够的。本文开发了两个协议，用于将密文从一种加密方案转换为另一种加密方案，同时保持底层明文。 Building Block 7 (Converting Cloud-RSA to Paillier ($[e^{\\bold{a \\cdot b}}]_R$ to $[e^{\\bold{a \\cdot b}}]_P$)) Building Block 8 (Converting one Paillier to Another Paillier ($[m]^1_P$ to $[m]^2_P$)) 在安全聚合中，由于各个数据拥有者的密钥都不一样，因此还需要将用某个数据拥有者密钥加密的密文转换为用另一个数据拥有者密钥加密的密文。 ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:3:3","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"PRIVACY-PRESERVING MACHINE LEARNING TRAINING WITH HEDA 在这一部分中，将详细介绍如何使用所提出的构建块来构建一个保护隐私的ML训练协议来训练LR模型。受版面限制，本文在完整版[16]中给出了用于训练SVM(协议1)和NB(协议3)的隐私保护ML协议的构造。 ","date":"2021-09-13","objectID":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/:4:0","tags":["PPML","HE"],"title":"论文笔记：Privacy-Preserving Machine Learning Training in IoT Aggregation Scenarios","uri":"/privacy-preserving-machine-learning-training-in-iot-aggregation-scenarios/"},{"categories":["Papers"],"content":"NDSS 2021 Qiao Zhang, Chunsheng Xin, and Hongyi Wu 系统描述 本文提出的GALA系统用于简化隐私保护神经网络模型中的线性计算(即矩阵-向量乘法和卷积)。基于HE的线性计算包括三个基本运算：同态加法(ADD)、乘法(MULT)和置换(PERM)。本研究表明，线性计算在总的计算开销中占主导地位，而基于HEs的线性计算中最耗时的部分是一系列更详细的PERM运算来实现点积和卷积。Gala的目标是最大限度地减少PERM操作，从而大大减少总体计算时间。我们把基于HE的线性计算看作是一系列的加法、乘法和PERM运算。线性计算的两个输入是来自客户端的加密向量(或通道)和来自服务器的明文权重矩阵(或核)。输出是加密的点积(或卷积)。每一步的目标是按照ADD、MULT和PERM的降序优先级选择最有效的操作。因此，GALA可以有效地减少基于HE域的线性计算的开销。最近的隐私保护神经网络框架可以将Gala集成为即插即用模块，以进一步提高它们的效率。我们还分析了GALA的(更好的)噪声管理和(保证的)系统安全性。 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:0:0","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"Row-encoding-share-RaS Matrix-Vector Multiplication 首先是矩阵-向量乘法，这里考虑的场景是服务器拥有明文参数矩阵，要与来自客户端的加密向量相乘。 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:1:0","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"朴素方法 假设现在有明文矩阵 $\\boldsymbol{w}$​​ 和密文向量 $[\\boldsymbol{x}]_c$​，矩阵维度为 $n_o \\times n_i$，向量长度为 $n_i$。 首先将矩阵拆分成 $n_o$ 个行向量； 然后分别计算这 $n_o$ 个行向量与 $[\\boldsymbol{x}]_c$​​ 的内积，得到 $n_o$ 个向量 $[\\boldsymbol{u}_0]_c, \\ \\dots$； 对上一步得到的每个向量，都通过 $\\log_2n_i$​​ 个 RaS 操作进行计算： 将向量的副本中的每个元素往前移动 $\\frac{n_i}{2}$ 个位置，再把移动后的向量副本与原副本相加； 将向量的副本中的每个元素往前移动 $\\frac{n_i}{4}$​​ 个位置，再把移动后的向量副本与原副本相加； … 重复上述操作直到移动的位数为0。 最后可以得到 $n_o$ 个向量，每个向量中第一个位置的值即为 $\\boldsymbol{w}$ 中对应行与 $[\\boldsymbol{x}]_c$​ 进行向量乘法的结果。​ 各操作次数： ScMult Perm Add $n_o$ $n_o \\log_2 n_i$ $n_o \\log_2 n_i$ 这种方法对密文空间利用率很低，导致线性计算效率非常低。 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:1:1","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"混合计算（GAZELLE） 为了充分利用密文中的 $n$​​ 个时隙并进一步降低复杂度，最先进的方案是通过利用在FC（全连接）层中 $n_o$ 通常远小于 $n_i$​ 的性质来组合对角编码和RaS。这种混合方法表明，昂贵的PERM操作的数量是关于 $n_i$​ 的函数而不是关于 $n_o$​ 的函数，因此加速了FC层的计算。 先把 $\\boldsymbol{w}$ 用对角线编码的方式进行编码，如上图的 Step(a)； 再将 $[\\boldsymbol{x}]_c$ 旋转 $n_o - 1$​ 次，加上原向量得到 $n_o$ 个向量； 将编码后的矩阵中得 $n_o$​ 个行向量与旋转得到的 $n_o$​​ 个向量分别作向量内积； 把上一步中得到的两个内积结果向量相加，再通过RaS操作即可获得最终结果。 各操作次数： ScMult HstPerm Perm Add $\\frac{n_i n_o}{n}$​ $\\frac{n_i n_o}{n} - 1$ $\\log_2 \\frac{n}{n_o}$ $\\frac{n_i n_o}{n} + \\log_2 \\frac{n}{n_o} - 1$​ 只有一个输出密文，与朴素方法相比，有效地提高了时隙利用率。 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:1:2","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"行编码-共享-RAS乘法（GALA） 本文提出的GALA框架是基于对混合方法的两个观察结果。首先，混合方法在PERM和HstPerm操作之间进行了权衡，其中PERM的数量(这是最昂贵的HE操作)与密文中的槽数量成正比。 类似地对 $\\boldsymbol{w}$ 进行编码，但这次仅仅是隔列把两个行向量进行一次交换； 将编码后的各个行向量分别与 $[\\boldsymbol{x}]_c$ 作内积； 将得到的第二个向量旋转 $n_o-1$ 个位置，再与第一个向量相加； 转换为明文下的Ras操作： 服务器生成一个随机向量，并用上一步得到的结果减去这个随机向量的密文； 服务器将得到的差发送给客户端； 客户端解密得到的向量，并在明文下进行RaS操作； 服务器对随机向量在明文下进行RaS操作。 各操作次数： ScMult Perm Add $\\frac{n_i n_o}{n}$ $\\frac{n_i n_o}{n} - 1$ $\\frac{n_i n_o}{n} - 1$ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:1:3","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"三者对比 方法 Perm HstPerm ScMult Add 朴素 $n_o \\log_2 n_i$ $0$ $n_o$ $n_o \\log_2 n_i$ GAZELLE $\\log_2 \\frac{n}{n_o}$ $\\frac{n_i n_o}{n} - 1$ $\\frac{n_i n_o}{n}$ $\\frac{n_i n_o}{n} + \\log_2 \\frac{n}{n_o} - 1$ GALA $\\frac{n_i n_o}{n} - 1$ $0$ $\\frac{n_i n_o}{n}$ $\\frac{n_i n_o}{n} - 1$ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:1:4","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"Kernel Grouping Based Convolution 接着是卷积，跟矩阵-向量乘法一样，先从单输入单输出（SISO）的基本卷积开始，再到本文之前最新的、以及本文的多输入多输出（MIMO）方案。 假设服务器有维度为 $k_w \\times k_h \\times c_i$​ 的卷积核，并且客户端将维度为 $u_w \\times u_h$ 的加密数据发送给服务器，服务器需要计算卷积核与加密数据的同态卷积。 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:2:0","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"基础的 SISO 卷积 SISO是MIMO的一个特殊情况：$c_i = c_o = 1$，如下图，加密数据 $[\\boldsymbol{x}]_c$ 维度为 $u_w \\times u_h$，卷积核 $\\mathsf{K}$ 维度为 $k_w \\times k_h$。 卷积过程可以可视化为将 $\\mathsf{K}$ 放在输入数据 $[\\boldsymbol{x}]_c$ 的不同位置，然后在每个位置计算卷积核与窗口内的相应数据值之间的元素乘积之和。如上图，首先是将 F5 放在 M1 的位置，然后一直移动 $\\mathsf{K}$​，把 F5 放在 M2 到 M9 的位置去计算不同窗口的卷积。 卷积通过以下步骤获得： 根据相应位置处的部分和形成核系数 $\\mathsf{f_j}$，如上图 Step(b)； 用相应的核系数与9个旋转后的 $\\mathsf{π_j}$​ 作内积； 最后把上一步的9个内积结果相加起来。 对第一步的理解： 核系数 $\\mathsf{f_j}$ 的生成是根据对应元素能影响到数据中的元素位置决定的：具体就是会对哪个元素产生影响，对应的位置就不为0。比如上图中的 F7，它在运算过程中能对 M2、M3、M5、M6 产生影响，因此对应的核系数就是这四个位置有值； $\\mathsf{π_j}$​​​​ 是根据核系数对应元素要与谁运算来生成的：具体就是根据对应的核系数的元素要与哪些元素作乘法，就把这些元素通过旋转移动到对应的位置。比如上图中要与 F7 进行计算的元素是 M4、M5、M7、M8，那么就是通过旋转操作将他们推到右上角。 各操作次数： HstPerm ScMult Add $k_wk_h - 1$ $k_wk_h$ $k_wk_h - 1$ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:2:1","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"基于输出旋转的 MIMO 卷积（GAZELLE） 现在考虑更一般的情况即MIMO，其中 $c_i$​​ 或 $c_o$​​​ 不为1。简单的方法就是把 $c_i$​​ 个输入频道加密成 $c_i$​​ 个密文，$c_o$​​ 个卷积核每个都包括 $c_i$​​​ 个滤波器。通过 SISO 将每个密文与每个滤波器作卷积，再把 $c_i$​ 个结果相加得到卷积。因此，朴素方法的各操作次数为： HstPerm ScMult Add $c_i(k_wk_h - 1)$​ $c_ic_ok_wk_h$​ $c_o(c_ik_wk_h - 1)$​ 假设密文中的时隙 $n$ 的数量通常大于信道大小 $u_wu_h$​，则共同输出密文中的密文利用率（输出期望结果的有意义的时隙）很低。 为了提高 MIMO 卷积的密文利用率和计算效率，现有的方法（输出旋转[38]）首先将 $c_n$​​ 通道的输入数据打包成一个密文，从而得到 $\\frac{c_i}{c_n}$​​ 个输入密文（如下图，其中四个输入通道形成两个密文，每个密文包括两个通道）。同时，将 $c_o$​​ 个卷积核看作是 $c_o \\times c_i$​​ 块，块的每一行包括一个卷积核的 $c_i$​​ 个2D滤波器。然后，将MIMO卷积视为矩阵向量乘法，其中元素乘法被卷积取代。由于每个密文有 $c_n$​​ 个通道，所以内核块被分成 $\\frac{c_oc_i}{c^2_n}$​​ 个块（如下图中的 Step(a)，其中卷积核块被分成 $\\mathsf{K1}$​​ 到 $\\mathsf{K4}$​）。 因为是想要利用类似上面提到的混合计算方法来计算，所以 Step(a) 中也按着混合计算中的方法，根据输入向量的维度，把矩阵分成了多个块。 这样每个输入密文可以通过 SISO 直接与每个划分块中的向量卷积，并且每个划分块的卷积是通过将卷积向量旋转到与对角线向量相同的核阶数并求和来获得的（见 Step(b)）。 最后通过 Perm 和 Add 操作得到了最终的 $\\frac{c_o}{c_n}$ 个输出密文。在这个过程中，对于 $\\frac{c_oc_i}{c^2_n}$ 个块中的每一个，一共有 $c_n$​​ 个类似 SISO 的卷积操作。根据上面对 SISO 的分析以及图中的步骤，每个块需要 $c_nk_wk_h$​ 个 ScMult 操作 $c_n - 1$​ 个 Perm 操作 $c_n(k_wk_h-1)+c_n - 1 = c_nk_wk_h - 1$​ 个 Add 操作 然后根据卷积核的分块方式，同一个卷积核中的不同滤波器被分到了 $\\frac{c_i}{c_n}$​​​​​ 个块中，因此他们还需要进行相加来获得对应卷积核最终的计算结果，同一个卷积核中的不同滤波器需要相加 $\\frac{c_i}{c_n} - 1$​​​ 次，而不同的卷积核被分进了 $\\frac{c_o}{c_n}$​​​ ​个块中，因此这个部分需要的相加次数为 $(\\frac{c_i}{c_n} - 1) \\frac{c_o}{c_n}$​​，加上每个块所需的相加次数，总的相加次数为： $$ \\begin{align}\r\\frac{c_oc_i}{c^2_n}(c_nk_wk_h - 1) + (\\frac{c_i}{c_n} - 1) \\frac{c_o}{c_n} = \\frac{c_o}{c_n}(c_ik_wk_h - 1)\r\\end{align} $$ \r而根据朴素方法的 HstPerm 次数为 $c_i(k_wk_h - 1)$​​，因此本方法的 HstPerm 次数为 $\\frac{c_i(k_wk_h - 1)}{c_n}$​​​。 各操作次数： Perm HstPerm ScMult Add $\\frac{c_ic_o}{c^2_n}(c_n-1)$ $\\frac{c_i}{c_n}(k_wk_h - 1)$​ $k_wk_h \\frac{c_ic_o}{c_n}$ $\\frac{c_o}{c_n}(c_ik_wk_h - 1)$​ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:2:2","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"基于核分组的 MIMO 卷积（GALA） 对于上面的 MIMO 卷积的一个关键观察是，$\\frac{c_oc_i}{c^2_n}$ 个块中的每一个需要 $c_n-1$ 个昂贵的PERM运算来获得该块的卷积，然而实际上不需要得到每个块的卷积。由于我们的目标是获得每个卷积核的卷积，因此在我们提出的 first-Add-second-Perm 方法（内核分组）中组合与相同内核相关联的块，以降低 PERM 成本。具体地说，在下图的 Step(a) 中，整个内核块被分成两个块 $\\mathsf{K1}$ 和 $\\mathsf{K2}$，使得每个块是对应于相同核（即 $\\mathsf{K1}$ 中的第一、第二个卷积核以及 $\\mathsf{K2}$​ 中的第三和第四个卷积核）的 $\\frac{c_i}{c_n} $​ 个被划分为含有 $c_n$ 个元素的块的组合。 对于每个新形成的块，所有向量首先通过类 SISO 卷积与相应的输入密文卷积。然后将与同一个卷积核相关联的卷积向量相加在一起（见上图 Step(b) 中旋转之前的卷积向量相加）。最后，将这些相加的向量旋转到相同的核阶数并求和，以获得卷积结果（见上图 Step(b) 中每个块的旋转和最终相加）。 核分组计算需要对 $\\frac{c_o}{c_n}$​ 个块中的每个进行 $c_n - 1$​​ 次 Perm 操作，比 GAZELLE 减少了 $\\frac{c_i}{c_n}$​ 倍。因为对于最先进的神经网络，$\\frac{c_i}{c_n}$ 可以达到 256，因此这种效率提升是可观的。 与上面讨论的基于输出旋转的 MIMO 卷积方案类似，该方案中有两个输出密文。对于每一个新形成的块，都有 $c_i$​​ 个类 SISO 卷积。然后，对于每一个 $c_n$​​ 核阶，都有 $\\frac{c_i}{c_n}$​​ 个卷积需要求和，这里需要 $c_n$​​ 个 Add 操作。这些相加的卷积被进一步旋转到相同的核阶数，并相加以得到最终的卷积。因此所提出的 MIMO 卷积总共需要 $\\frac{c_o}{c_n}(c_n-1)$​​ 个 Perm 操作、$\\frac{c_i}{c_n}(k_wk_h - 1)$​​ 个 HstPerm 操作、$k_wk_h \\frac{c_ic_o}{c_n}$​​ 个 ScMult 操作和 $\\frac{c_o}{c_n}(c_ik_wk_h - 1)$​​ 个 Add 操作。 各操作次数： Perm HstPerm ScMult Add $\\frac{c_o}{c_n}(c_n-1)$​ $\\frac{c_i}{c_n}(k_wk_h - 1)$​ $k_wk_h \\frac{c_ic_o}{c_n}$ $\\frac{c_o}{c_n}(c_ik_wk_h - 1)$​ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:2:3","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"两者对比 方法 Perm HstPerm ScMult Add GAZELLE $\\frac{c_ic_o}{c^2_n}(c_n-1)$​ $\\frac{c_i}{c_n}(k_wk_h - 1)$ $k_wk_h \\frac{c_ic_o}{c_n}$ $\\frac{c_o}{c_n}(c_ik_wk_h - 1)$ GALA $\\frac{c_o}{c_n}(c_n-1)$ $\\frac{c_i}{c_n}(k_wk_h - 1)$ $k_wk_h \\frac{c_ic_o}{c_n}$ $\\frac{c_o}{c_n}(c_ik_wk_h - 1)$ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:2:4","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"噪音管理 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:3:0","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"矩阵-向量乘法 方法 计算后的噪音 密文数量 朴素 $n_i \\eta_0 \\eta_{mult}+(n_i-1)\\eta_{rot}$ $n_o$ GAZELLE $n_i\\eta_0\\eta_{mult} + [\\frac{n_in_o-n}{n_o}\\eta_{mult}+\\frac{n-n_o}{n_o}]\\eta_{rot}$​ $1$ GALA $\\frac{n_in_o}{n}\\eta_0\\eta_{mult} + (\\frac{n_in_o}{n}-1)\\eta_{rot}$ $1$ ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:3:1","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Papers"],"content":"卷积 方法 计算后的噪音 密文数量 GAZELLE $c_i \\eta_\\Delta+\\frac{c_i}{c_n}(n_i-1)\\eta_{rot}$ $\\frac{c_o}{c_n}$​ GALA $c_i \\eta_\\Delta+\\eta_{rot}$ $\\frac{c_o}{c_n}$ 其中 $\\eta_\\Delta = k_wk_h\\eta_{mult}\\eta_0 + (k_wk_h-1)\\eta_{rot}\\eta_{mult}$​。 ","date":"2021-08-07","objectID":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/:3:2","tags":["PPML","HE"],"title":"论文笔记：GALA - Greedy ComputAtion for Linear Algebra in Privacy-Preserved Neural Networks","uri":"/gala-greedy-computation-for-linear-algebra-in-privacy-preserved-neural-networks/"},{"categories":["Coding"],"content":"目前比较流行的一套接口规范就是 RESTful api，REST（Representational State Transfer）,中文翻译叫\"表述性状态转移\",它首次出现在 2000 年 Roy Fielding 的博士论文中，Roy Fielding 是 HTTP 规范的主要编写者之一。他在论文中提到：“我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST 指的是一组架构约束条件和原则。“如果一个架构符合 REST 的约束条件和原则，我们就称它为 RESTful 架构，REST 其实并没有创造新的技术、组件或服务，在我的理解中，它更应该是一种理念、一种思想，利用 Web 的现有特征和能力，更好地诠释和体现现有 web 标准中的一些准则和约束。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:0:0","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:0","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则一：URI 应该将 api 部署在专用域名之下。 URL 中尽量不用大写。 URI 中不应该出现动词，动词应该使用 HTTP 方法表示但是如果无法表示，也可使用动词，例如：search 没有对应的 HTTP 方法,可以在路径中使用 search，更加直观。 URI 中的名词表示资源集合，使用复数形式。 URI 可以包含 queryString，避免层级过深。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:1","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则二：HTTP 动词 对于资源的具体操作类型，由 HTTP 动词表示，常用的 HTTP 动词有下面五个： GET：从服务器取出资源（一项或多项）。 POST：在服务器新建一个资源。 PUT：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH：在服务器更新资源（客户端提供改变的属性）。 DELETE：从服务器删除资源。 还有两个不常用的 HTTP 动词： HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 例子： 用户管理模块： 1. [POST] http：//lou.springboot.tech/users // 新增 2. [GET] http：//lou.springboot.tech/users?page=1\u0026rows=10 // 列表查询 3. [PUT] http：//lou.springboot.tech/users/12 // 修改 4. [DELETE] http：//lou.springboot.tech/users/12 // 删除 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:2","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则三：状态码（Status Codes） 处理请求后，服务端需向客户端返回的状态码和提示信息。 常见状态码**(状态码可自行设计，只需开发者约定好规范即可)**： 200：SUCCESS 请求成功。 401：Unauthorized 无权限。 403：Forbidden 禁止访问。 410：Gone 无此资源。 500：INTERNAL SERVER ERROR 服务器发生错误。 … ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:3","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则四：错误处理 如果服务器发生错误或者资源不可达，应该向用户返回出错信息。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:4","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则五：服务端数据返回 后端的返回结果最好使用 JSON 格式，且格式统一。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:5","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"基本原则六：版本控制 规范的 api 应该包含版本信息，在 RESTful api 中，最简单的包含版本的方法是将版本信息放到 url 中，如： [GET] http：//lou.springboot.tech/v1/users?page=1\u0026rows=10 [PUT] http：//lou.springboot.tech/v1/users/12 另一种做法是，使用 HTTP header 中的 accept 来传递版本信息。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:1:6","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"安全原则 以下为接口安全原则的注意事项： ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:2:0","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"安全原则一：Authentication 和 Permission Authentication 指用户认证，Permission 指权限机制，这两点是使 RESTful api 强大、灵活和安全的基本保障。 常用的认证机制是 Basic Auth 和 OAuth，RESTful api 开发中，除非 api 非常简单，且没有潜在的安全性问题，否则，认证机制是必须实现的，并应用到 api 中去。Basic Auth 非常简单，很多框架都集成了 Basic Auth 的实现，自己写一个也能很快搞定，OAuth 目前已经成为企业级服务的标配，其相关的开源实现方案非常丰富。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:2:1","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Coding"],"content":"安全原则二：CORS CORS 即 Cross-origin resource sharing，在 RESTful api 开发中，主要是为 js 服务的，解决调用 RESTful api 时的跨域问题。 由于固有的安全机制，js 的跨域请求时是无法被服务器成功响应的。现在前后端分离日益成为 web 开发主流方式的大趋势下，后台逐渐趋向指提供 api 服务，为各客户端提供数据及相关操作，而网站的开发全部交给前端搞定，网站和 api 服务很少部署在同一台服务器上并使用相同的端口，js 的跨域请求时普遍存在的，开发 RESTful api 时，通常都要考虑到 CORS 功能的实现，以便 js 能正常使用 api。 目前各主流 web 开发语言都有很多优秀的实现 CORS 的开源库，我们在开发 RESTful api 时，要注意 CORS 功能的实现，直接拿现有的轮子来用即可。 ","date":"2020-12-23","objectID":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/:2:2","tags":["RESTful"],"title":"RESTful api 设计规范","uri":"/restful-api-%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"},{"categories":["Env"],"content":"mysql-connector-java与Mysql对应版本 Connector/J version Driver Type JDBC version MySQL Server version Status 5.1 4 3.0, 4.0, 4.1, 4.2 5.6*, 5.7*, 8.0* General availability 8.0 4 4.2 5.6, 5.7, 8.0 General availability. Recommended version MySQL Connector/J 8.0 is highly recommended for use with MySQL Server 8.0, 5.7, and 5.6. Please upgrade to MySQL Connector/J 8.0. 官方更推荐MySQL5.6以上使用connector/j 8.0 ","date":"2020-11-20","objectID":"/mysql-connector-java%E4%B8%8Emysqljava%E7%9A%84%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC/:1:0","tags":["Mysql","Java"],"title":"mysql-connector-java与Mysql、Java的对应版本","uri":"/mysql-connector-java%E4%B8%8Emysqljava%E7%9A%84%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC/"},{"categories":["Env"],"content":"mysql-connector-java与Java对应版本 Connector/J version JRE Supported JDK required for compiling source code 5.1 1.5.x, 1.6.x, 1.7.x*, 1.8.x** 1.5.x and 1.8.x *** 8.0 1.8.x 1.8.x JRE 1.7 support requires Connector/J 5.1.21 and higher. JRE 1.7 需要connector/J 5.1.21 以上 ","date":"2020-11-20","objectID":"/mysql-connector-java%E4%B8%8Emysqljava%E7%9A%84%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC/:2:0","tags":["Mysql","Java"],"title":"mysql-connector-java与Mysql、Java的对应版本","uri":"/mysql-connector-java%E4%B8%8Emysqljava%E7%9A%84%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC/"},{"categories":["Coding"],"content":"MyBatis Generator工具用于将数据库中的表反转成对应的 Domain、XML文件 和 对应的 DAO Java文件。 ","date":"2020-11-20","objectID":"/mybatis-generator-%E4%BD%BF%E7%94%A8/:0:0","tags":["Mybatis"],"title":"Mybatis Generator 使用","uri":"/mybatis-generator-%E4%BD%BF%E7%94%A8/"},{"categories":["Coding"],"content":"引入依赖 在 pom.xml 中添加下面的配置： \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-core\u003c/artifactId\u003e \u003cversion\u003e1.4.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2020-11-20","objectID":"/mybatis-generator-%E4%BD%BF%E7%94%A8/:1:0","tags":["Mybatis"],"title":"Mybatis Generator 使用","uri":"/mybatis-generator-%E4%BD%BF%E7%94%A8/"},{"categories":["Coding"],"content":"编辑配置文件 在项目目录下新建 mbg.xml 文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"DB2Tables\" targetRuntime=\"MyBatis3\"\u003e \u003c!-- 配置注释的生成，这里配置不生成注释 --\u003e \u003ccommentGenerator\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\"/\u003e \u003c/commentGenerator\u003e \u003c!-- 配置数据库连接 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud?serverTimezone=UTC\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\" userId=\"root\" password=\"960914\"\u003e \u003c/jdbcConnection\u003e \u003cjavaTypeResolver \u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\" /\u003e \u003c/javaTypeResolver\u003e \u003c!-- 实体类生成配置 --\u003e \u003cjavaModelGenerator targetPackage=\"cn.yuyingwai.crud.bean\" targetProject=\".\\src\\main\\java\"\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003cproperty name=\"trimStrings\" value=\"true\" /\u003e \u003c/javaModelGenerator\u003e \u003c!-- mapper生成配置 --\u003e \u003csqlMapGenerator targetPackage=\"mapper\" targetProject=\".\\src\\main\\resources\"\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/sqlMapGenerator\u003e \u003c!-- dao类生成配置 --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.yuyingwai.crud.dao\" targetProject=\".\\src\\main\\java\"\u003e \u003cproperty name=\"enableSubPackages\" value=\"true\" /\u003e \u003c/javaClientGenerator\u003e \u003c!-- 要生成的对应数据库中的表 --\u003e \u003ctable tableName=\"tbl_emp\" domainObjectName=\"Employee\"\u003e\u003c/table\u003e \u003ctable tableName=\"tbl_dept\" domainObjectName=\"Department\"\u003e\u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e 数据库驱动要与mysql以及jdk的版本对应数据库连接要输入参数时，需要将 \u0026 写成 \u0026amp;； 生成配置中的 targetPackage 为需要生成的类或文件所在的包，targetProject 为需要生成的类或文件的路径。 ","date":"2020-11-20","objectID":"/mybatis-generator-%E4%BD%BF%E7%94%A8/:2:0","tags":["Mybatis"],"title":"Mybatis Generator 使用","uri":"/mybatis-generator-%E4%BD%BF%E7%94%A8/"},{"categories":["Coding"],"content":"通过编码和配置文件运行 在测试包下新建 MGBTest 类： public class MBGTest { public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException { List\u003cString\u003e warnings = new ArrayList\u003cString\u003e(); boolean overwrite = true; File configFile = new File(\"mbg.xml\"); // 配置文件位置 ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } } 运行该类，即可生成对应的实体类以及mapper文件。 ","date":"2020-11-20","objectID":"/mybatis-generator-%E4%BD%BF%E7%94%A8/:3:0","tags":["Mybatis"],"title":"Mybatis Generator 使用","uri":"/mybatis-generator-%E4%BD%BF%E7%94%A8/"},{"categories":["Papers"],"content":"Tong Li, Jin Li, Xiaofeng Chen, Zheli Liu, Wenjing Lou, and Y. Thomas Hou TDSC 2020 https://ieeexplore.ieee.org/document/8981947 摘要 近十年来，深度学习技术被广泛用于建立人工智能应用程序，这使得许多数据分析任务取得了成功，如风险评估、医学预测和人脸识别。由于深度学习的有效性与可用的数据量成正比，大规模收集海量数据至关重要。考虑到隐私和安全问题通常会阻止数据所有者提供敏感数据用于培训，研究人员提出了几种技术来在包含多方的机器学习系统中为数据提供隐私保证。然而，所有这些工作都在培训过程中引起了数据所有者之间的频繁交互，从而导致数据所有者付出了高昂的通信成本。为此，本文提出了一种新的服务器辅助框架，称为非交互式隐私保护多方机器学习(NPMML)，该框架支持安全的机器学习任务，无需数据所有者的参与。NPMML框架显著降低了数据所有者在多方机器学习中的通信开销。此外，我们还设计了一个基于NPMML的多层神经网络的具体结构。最后，通过原型实现对NPMML的性能进行了评估。实验结果表明，NPMML对数据拥有者来说是一种高效的通信方式。 贡献 作者探索了一种新的多方隐私保护机器学习任务框架。对于他们来说有两个挑战：第一个挑战是，大多数机器学习算法，例如神经网络，要求数据所有者迭代地改进其明文数据集的中间结果。如果训练者直接更新加密版本的数据集的中间结果，则最终模型的输出将带有更差的最终结果。因此，中间结果的传递不可避免地会导致频繁的互动。或者，第二个挑战是缺乏有效的密码技术来构建上述非交互框架中的安全协议。尽管完全同态加密(FHE)可以实现机器学习任务的安全计算，但它们仍然会带来相当大的计算开销。 上述两个挑战促使作者探索如何以有效沟通的方式管理隐私保护学习问题。为此，本文提出了一个新的框架，称为非交互式隐私保护多方机器学习(NPMML)，它支持安全的机器学习任务，而不需要数据所有者的参与。 非交互式框架。本文提出了NPMML的框架。这个框架是服务器辅助的，它使训练者能够在加密数据上训练机器学习模型，而无需与数据所有者进行在线交互。与交互式学习系统相比，使用NPMML的多方学习系统为数据所有者带来了更少的通信开销。 隐私保护训练协议。基于NPMML框架，给出了训练多层神经网络的具体结构。在构建过程中，本文设计了一种新的训练协议来保护训练结果的私密性，并设计了一种加密方法来保护训练数据的私密性。这些组件共同保证了 数据所有者在上传加密数据后不必维护在线训练； 训练者可以使用加密数据迭代更新神经网络模型，最终得到训练良好的模型。 实现。作者实现了一个NPMML原型，并对其性能进行了评估。实验结果表明，NPMML对数据拥有者和训练者都具有良好的通信效率。 NPMML框架 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:0:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"结构 在NPMML系统中主要有三个实体，包括数据所有者、训练者和称为加密服务提供商（CSP）的辅助第三方。该系统具有数据采集、机器学习算法等机器学习任务的基本功能。 数据所有者：在NPMML系统中，数据所有者是一个持有一组数据的实体，它希望为机器学习任务提供数据，而不需要稍后的学习结果。为了保护隐私，所有者需要将数据加密到受保护的版本。因此，在上传数据后，所有者应该离线，不参加培训。 CSP：设计NPMML的一个挑战是，大多数学习任务都要求数据所有者在每次学习迭代中计算并提交他们的明文数据集的中间结果。为了将数据所有者从这类在线任务中解脱出来，本文引入了一个不可信的辅助服务器，该服务器在训练期间承担一些必要的密码操作。它的职责包括发布公共参数，向数据所有者发布加密密钥，以及在学习任务上进行合作。称这个实体为CSP。 训练者：与数据所有者不同的是，训练者没有数据，而是试图在从数据所有者那里收集的训练数据上构建机器学习模型。在接收到足够的加密数据后，训练者可以使用CSP运行训练协议，就像在明文数据上执行学习算法一样。该协议持续了许多次迭代，训练者最终将获得良好的模型。考虑到这个模型可能具有商业价值，训练者不会与CSP合谋，也不愿将模型透露给其他人。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:1:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"威胁模型 在NPMML中，外部窃听者或受攻击的内部实体可能是敌手。 通常情况下，公共环境中的敌手被认为是诚实但好奇的。也就是说，这些攻击者将遵循学习系统的协议，但也会试图根据其所拥有的信息确定尽可能多的秘密信息。然而，有时比外部对手更强大的机器学习任务的参与者可能会主动篡改一些中间消息，以泄露他人的敏感信息。因此，本文主要考虑三类互不勾结的内部对手： 尝试从加密的训练数据中检索敏感信息的在线训练者； 一个诚实但好奇的CSP，试图从加密的训练数据和训练的分类器模型中检索敏感信息； 一个诚实但好奇的数据所有者，试图从不属于他/她的加密训练数据中检索敏感信息，以及训练好的分类器模型。 一种多层感知结构 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:2:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"概览 本文构建了一个三层感知方案。基于本文提出的系统架构，这些步骤应该包括初始化、数据收集和隐私保护测试。简要概述如下所示。 初始化：在初始化过程中，公共参数由CSP生成。CSP还为每个所有者的数据加密生成密钥对。 数据收集：在将数据上传到训练者之前，每个数据所有者使用其密钥对将一组数据加密为密文版本。训练者收集这些密文作为训练数据。 隐私保护训练：在训练期间，本文的协议在训练员和CSP之间一轮接一轮地执行。在每次学习迭代中，训练器与CSP进行通信，以使用SGD算法更新当前模型。最后，训练者在明文中得到分类器模型。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:3:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"加密数据 通常来讲，如果数据所有者简单地使用没有特定结构的加密方案将数据记录加密成密文，训练者几乎不能利用该加密记录进行训练操作，包括转发神经网络和计算SGD算法的导数。为了扭转这种情况，本文设计了一种加密数据集中每条记录的方法。 加密。本文选择一次性掩码结构和公钥加密方案 $\\mathcal{PKE} = {Gen,Enc,Dec}$ 来生成由两部分组成的密文，这两部分分别由训练者和CSP使用。考虑到本文的NPMML将面临主动敌手(即主动训练者)的威胁，作者采用了CCA-2安全公钥加密方案(如RSA-PKCS#1)。为方便起见，本文将数据记录表示为向量形式，这样具有特征的记录可以表示为 $a$ 维向量 $\\mathbf{x}$。 具体地说，向数据所有者发放模数为 $n$ 的 $\\mathcal{PKE}$ 的公钥 $pk$。当数据所有者需要上传向量 $\\mathbf{x}$ 以及对应的标签 $y$ 时，他/她将 选择掩码对，即随机非奇异整数矩阵 $\\mathbf{A} \\in \\mathbb{Z}^{a \\times a}_n$ 及其逆矩阵 $\\mathbf{A}^{-1} \\in \\mathbb{Z}^{a \\times a}$，设置 $\\mathbf{z}^{(1)} \\leftarrow \\mathbf{A}$； 将掩码后的向量加密以及填充后得到 $\\mathbf{z}^{(2)} \\leftarrow \\mathcal{PKE}.Enc_{pk}(\\mathbf{A}^{-1} \\cdot \\mathbf{x})$； 输出结果，即元组 $\\mathbf{z} \\leftarrow \\mathbf{z}^{(1)} || \\mathbf{z}^{(2)}$。 这里，本文将矩阵(或向量)的每个元素的加密表示为矩阵(或向量)的加密。例如，如果 $a \\times b$ 矩阵是 $\\mathbf{M} = {m_{kj} } (1 \\leq k \\leq a, 1 \\leq j \\leq b)$，则 $\\mathbf{M}$ 的加密表示一组元素 ${m_{kj}} (1 \\leq k \\leq a, 1 \\leq j \\leq b)$ 的加密。 该方案中的大多数运算都使用浮点数，这些浮点数不能在本文选择的密码体制(如 $\\mathcal{PKE}$ 和Paillier密码体制)的密文上计算。因此，浮点数应该转换为以 $\\mathbb{Z}_n$ 为单位的整数，其中 $n$ 是所采用的密码系统的模数。本文用IEEE754双精度浮点数表示实数，精度为 $52$ 位，并采用了[7]中的转换方法，即将浮点数乘以预先商量好的公共数 $l$。此外，在明文空间中，负数可以表示为大的正数。为了正确地处理负数，必须确保 $\\log_2n \u003e 6\\log_2l$，因为本文中明文上的最大正数的大小小于 $6\\log_2l$ 位。通常，明文空间非常大，而 $l$ 保持较小。 请注意，一次性掩码 $\\mathbf{A}^{-1}$ 仅用于向量 $\\mathbf{x}$，且与 $\\mathbf{x}$ 无关，因此这两个部分中的至少一个不会泄露 $\\mathbf{x}$ 的信息。在训练者看来，尽管它能够得到这两个部分，但如果没有可用于解密填充的可用密钥 $sk$，$\\mathbf{x}$ 仍然不能被揭示。或者，只要CSP仅从训练者接收 $\\mathbf{z}^{(2)} = \\mathcal{PKE}.Enc_{pk}(\\mathbf{A}^{-1} \\cdot \\mathbf{x})$，它也不能恢复 $\\mathbf{x}$ 的明文。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:4:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"初始化和收集数据 初始化步骤和数据收集步骤是运行训练方案的前提。本文将每个所有者表示为 $\\mathcal{O}$，每个训练者表示为 $\\mathcal{T}$，密码服务提供商表示为 $\\mathcal{CSP}$。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:5:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"初始化 如上所述，在该系统中应用了具有安全参数 $\\lambda$ 的公钥加密方案 $\\mathcal{PKE} = {Gen,Enc,Dec}$。初始化步骤按如下方式执行。 对于每个 $\\mathcal{O}$，$\\mathcal{CSP}$ 运行 $Gen(1^\\lambda)$ 以生成密钥对 $\\langle pk, sk \\rangle$； $\\mathcal{CSP}$ 将公钥发布给每个 $\\mathcal{O}$； 每个 $\\mathcal{T}$ 为其自身生成Paillier密钥对 $\\langle pk_p, sk_p \\rangle$，并将 $pk_p$(包含其模数 $n$，$|n|=\\lambda$)公开。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:5:1","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"收集数据 为保护数据隐私，每个数据所有者应对其数据集中的每条记录进行加密。本文在算法2中给出了所有者加密操作的一个例子。 在加密了 ${ {\\mathbf{x}_1, y_1 },…,{\\mathbf{x}_m, y_m } }$ 后，数据所有者通过一个安全协议（可以被视为没有窃听者的安全通道）将 ${ {\\mathbf{z}_1, y_1 },…,{\\mathbf{z}_m, y_m } }$ 发送给一个训练者。因此，在开始训练之前，训练者已经收集了该加密数据集作为训练数据集的一部分。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:5:2","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"隐私保护训练协议 隐私保护训练协议是NPMML三层感知框架的核心组成部分。通过执行该协议，训练者可以根据训练数据对其模型进行文字更新，最终得到训练好的模型。 根据SGD算法，该协议应该允许训练者在每次学习迭代中对一批训练数据计算当前模型的更新，即误差函数的梯度。然而，使用适当的秘密密钥 $sk$，数据集中的任何加密记录 $\\mathbf{z} = \\mathbf{A} || \\mathcal{PKE}.Enc_{pk}(\\mathbf{A}^{-1} \\cdot \\mathbf{x})$ 不能被训练者本身直接利用。此外，如果训练者试图与CSP合作处理这样的记录 $\\mathbf{z}$，它将遭遇另一个严重的隐私问题。也就是说，清晰的通信会将一些中间模型以及训练数据暴露给不可信的CSP。 在这种情况下，作者设计训练协议的诀窍是，训练者将当前模型的一些消息加密为令牌，然后提交这些令牌来请求CSP的服务。因此，CSP能够以保护隐私的方式完成梯度计算的操作。 然后，本文展示了 $\\mathcal{CSP}$ 和持有从所有者 $\\mathcal{O}$ 收集的加密数据集的单个训练者 $\\mathcal{T}$ 之间的协议的细节。该协议可以很容易地扩展以支持多个所有者和训练者。 在第一次学习迭代开始之前，$\\mathcal{T}$ 已经从 $\\mathcal{O}$ 收集了 $m$ 大小的加密训练集 ${ {\\mathbf{z}_1, y_1 },…,{\\mathbf{z}_m, y_m } }$，并且初始化了神经网络模型 $\\Theta_0 = {\\mathbf{W}^{(h)}_0, \\mathbf{W}^{(o)}_0 }$，其中每个元素 $w^{(o)}_{i,j}$ 和 $w^{(h)}_{j,k}$ 可以从 $\\mathbb{R}$ 随机采样。在本文的训练协议的学习迭代之后，$\\mathcal{T}$ 利用加密数据集的一系列批次来更新当前模型。如算法3所示，每次学习迭代主要包括三个步骤：生成请求、计算梯度和更新模型。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:6:0","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"生成请求 在每次迭代开始时，$\\mathcal{T}$ 选择加密训练集的随机大小为 $s$ 的批次 $S_t$。然后，$\\mathcal{T}$ 使用该批和加密方案 $\\mathcal{PKE}$ 和 $\\mathcal{P}$ 对部分当前模型 $\\Theta_{t-1}$ 进行盲化处理。为了处理 $S_t$ 中的每个数据记录 ${\\mathbf{z},y}$，$\\mathcal{T}$ 秘密地保存掩码 $\\mathbf{z^{(1)}} = \\mathbf{A}$，并将填充 $\\mathbf{z}^{(2)} = \\mathcal{PKE}.Enc_{pk}(\\mathbf{A}^{-1} \\cdot \\mathbf{x})$ 视为 $\\tau^{(1)}$。$\\tau^{(2)} = \\mathcal{PKE}.Enc_{pk}(\\mathbf{W}^{(h)}_{t-1} \\cdot \\mathbf{A})$ 用于使 $\\mathcal{CSP}$ 能够在不知道 $\\mathbf{x}$ 和 $\\mathbf{W}^{(h)}_{t-1}$ 的情况下将 $\\mathbf{x}$ 前向传播到隐藏层。注意，$\\mathbf{W}^{(h)}_{t-1}$ 通过乘以 $l$ 被转换为整数，$\\mathbf{x}$ 也是。其余部分 $\\tau^{(3)} = \\mathcal{E}(\\mathbf{y})$ 是标签的Paillier密文。向量 $\\mathbf{y}$ 是 $y$ 的独热格式，并且在加密之前将通过乘以 $l^2$ 将其转换为整数向量。事实上，对于Paillier密码体制，整数不会以可以忽略的概率 $(1-\\frac{1}{p})(1-\\frac{1}{q})$ 出现在 $\\mathbb{Z}^*_n \\simeq \\mathbb{Z}^*_p \\times \\mathbb{Z}^*_q$ 中，其中 $p$ 和 $q$ 是不公开的素数。因此，为方便起见，可以将Paillier明文空间 $\\mathbb{Z}^*_n$ 近似地视为 $\\mathbb{Z}_n$。所有的 $\\tau^{(1)} || \\tau^{(2)} || \\tau^{(3)}$ 组成一个大小为 $s$ 的集合 $\\tau_1$，它与 $S_t$ 一一对应。 分离部分 $\\tau_2 = \\mathcal{E}(\\mathbf{W}^{(o)}_{t-1})$ 和 $\\tau_3 = \\mathbf{W}^{(o)}_{t-1} \\cdot \\mathbf{B}^{-1}_t$ 用于使 $\\mathcal{CSP}$ 能够安全地转发输出层并计算偏导数。输出层权重 $\\mathbf{W}^{(o)}_{t-1}$ 也应在盲化之前通过乘以 $l$ 转换为整数矩阵。注意，掩蔽 $\\mathbf{W}^{(o)}_{t-1}$ 的随机选择的掩码 $\\mathbf{B}_t$ 是一次性的，使得其仅用于当前学习迭代。$\\mathcal{T}$ 需要秘密存储 $\\mathbf{B}_t$，直到此迭代结束。 然后，$\\mathcal{T}$ 向 $\\mathcal{CSP}$ 发送请求 $Req = {\\tau_1, \\tau_2, \\tau_3}$ 进行训练。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:6:1","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"计算梯度 $\\mathcal{CSP}$ 收到请求后，对 $Req$ 中包含受保护内容执行反向传播和求偏导操作。与基于明文数据的SGD算法不同，这里的中间结果是一种特殊的形式。 当按 $\\tau_1$ 中的每个元素进行神经网络前向传播时，$\\mathcal{CSP}$ 尝试获得作为Sigmoid函数的输入的向量 $\\mathbf{u} = (u_1, …,u_b)$，以便通过计算 $(f(u_1),f(u_2),…,f(u_b))$ 来得到隐藏层 $\\mathbf{h}$。中间结果 $\\mathbf{u}$ 由 $\\mathbf{W}'^{(h)} \\cdot \\mathbf{x}'$(等于 $\\mathbf{W}^{(h)}_{t-1} \\cdot \\mathbf{A} \\cdot \\mathbf{A}^{-1} \\cdot \\mathbf{x} = \\mathbf{W}^{(h)}_{t-1} \\cdot \\mathbf{x}$)计算得到，因此，$\\mathbf{u}$ 可以用 $l^2$ 恢复为浮点向量，$\\mathbf{h}$ 可以用 $l$ 转换成整数向量。在不直接知道 $\\mathbf{W}^{(o)}_{t-1}$ 的情况下，$\\mathcal{CSP}$ 只能通过计算 $\\tau_2 \\odot \\mathbf{h}$ 来获得一个特殊向量 $\\mathbf{o}'$。实际上 $\\mathbf{o}'$ 是Paillier加密的密文 $\\mathcal{E}(\\mathbf{o})$。 根据3中所示的基于 $L^2$ 范数的损失函数 $E$，3层感知中的偏导数可描述如下： $$ \\frac{\\partial E}{\\partial w^{(o)}_{i,j}} = -(y_i - o_i) h_j \\tag{2} $$ $$ \\frac{\\partial E}{\\partial w^{(h)}_{i,j}} = -h_j(1 - h_j) x_k \\sum^c_{i=1}[(y_i - o_i)w^{(o)}_{i,j}] \\tag{3} $$ 然后，$\\mathcal{CSP}$ 的任务是根据元素 $\\tau^{(1)} | \\tau^{(2)} | \\tau^{(3)}$ 计算偏导数。输出层的偏导数矩阵 $\\delta_1 \\in \\mathbb{Z}^{c \\times b}_{n^2}$ 很容易通过计算 $(\\mathbf{o'} \\ominus \\tau^{(2)}) \\odot \\mathbf{h}^T$。$\\delta_1$ 实际内容为 $\\delta^{(1)} = (\\mathbf{o'} \\ominus \\tau^{(2)}) \\odot \\mathbf{h}^T = \\mathcal{E}(- (\\mathbf{y}-\\mathbf{o})) \\odot \\mathbf{h}^T = \\mathcal{E}(-(\\mathbf{y}-\\mathbf{o}) \\cdot \\mathbf{h}^T) = \\mathcal{E}(\\mathbf{D}^{(o)})$。隐藏层的加密偏导数矩阵很难直接生成。计算这个矩阵的一种直接方法是将方程(3)分成两个因子：$-h_j(1 - h_j) x_k$ 和 $\\sum^c_{i=1}[(y_i - o_i)w^{(o)}_{i,j}]$。不幸的是，泄露后一个因素将破坏输出层 $\\mathbf{o}$ 的保密性，并进一步导致 $\\mathbf{x}$ 的泄漏。任何实体都不能泄露向量 $\\mathbf{o}$，因为 如果 $\\mathcal{T}$ 持有 $o_i$，则将分别从公式(2)和公式(3)中推导出 $h_j$ 和 $x_k$； 如果 $\\mathcal{CSP}$ 持有 $o_i$，则它将通过计算公式(2)来获得 $\\frac{\\partial E}{\\partial w^{(o)}_{i,j}}$。 如果密文矩阵 $(\\tau^{(2)} \\ominus \\mathbf{o'}) \\odot \\tau_3$ 表示矩阵的Paillier密文（第 $(j,k)$ 个元素为 $\\sum^c_{i=1}[(y_i - o_i) w^{(o)}_{i,j}]$）被发送回给 $\\mathcal{T}$，当 $b\u003ec$ 时，$\\mathcal{T}$ 可以通过解线性方程组来提取 $\\mathbf{o}$。为了扭转这种情况，作者引入了 $\\gamma \\in \\mathbb{Z}_n$ 作为盲化因子对 $\\delta^{(2)}$ 和 $\\delta^{(3)}$ 进行盲化。为方便起见，作者设置了一个向量 $\\mathbf{v} = (v_1, …,v_b)$，使得每个 $v_j = -h_j(1-h_j)$，其中 $1 \\leq j \\leq b$，且其整数版本是 $v$ 的 $l$ 倍(可能存在截断误差)。 所有的 $\\delta^{(1)} || \\delta^{(2)} || \\delta^{(3)}$ 构成另一个大小为 $s$ 的集合 $Res$，它与 $\\tau_1$ 一一对应，$\\mathcal{CSP}$ 将 $Res$ 返回给 $\\mathcal{T}$。$\\delta^{(2)}$ 和 $\\delta^{(3)}$ 的内容实际上是 $\\delta^{(2)} = \\mathcal{E}(\\gamma^{-1} \\cdot \\mathbf{v} \\cdot (\\mathbf{x'})^T)$ 和 $\\delta^{(3)} = \\gamma \\odot ((\\tau^{(2)} \\ominus \\mathbf{o'})^T \\odot \\tau_3)=\\gamma \\odot \\mathcal{E}((\\mathbf{y} - \\mathbf{o})^T) \\odot (\\mathbf{W}^{(o)}_{t-1} \\cdot \\mathbf{B}^{-1}) = \\mathcal{E}(\\gamma \\cdot (\\mathbf{y} - \\mathbf{o})^T \\cdot (\\mathbf{W}^{(o)}_{t-1} \\cdot \\mathbf{B}^{-1}))$。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:6:2","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"更新模型 对于大小为 $s$ 的集合 $Res$ 中的每个元素，$\\mathcal{T}$ 将恢复两个导数矩阵 $\\mathbf{D}^{(h)}$ 和$\\mathbf{D}^{(o)}$。注意，$\\mathbf{D}^{(o)}$ 被因子 $l^2$ 恢复为浮点矩阵，而 $\\mathbf{D}^{(h)}$ 被因子 $l^5$ 恢复为浮点矩阵。 导数矩阵的正确性很容易推导出来。$\\mathcal{D}(\\delta^{(1)}) = \\mathbf{D}^{(o)}$ 是显而易见的。矩阵 $\\mathbf{D}^{(1)}$ 为 $\\mathcal{D}(\\delta^{(2)}) \\cdot \\mathbf{A}^T = \\gamma^{-1} \\cdot \\mathbf{v} \\cdot \\mathbf{x}^T \\cdot (\\mathbf{A^{-1}}) \\cdot \\mathbf{A}^T = \\gamma^{-1} \\cdot \\mathbf{v} \\cdot \\mathbf{x}^T$ 其中第 $(j，k)$ 个元素为 $(v_j \\cdot x_k) \\cdot \\gamma^{-1}$。矩阵 $\\mathbf{D}^{(2)}$ 为 $\\mathcal{D}(\\delta^{(3)}) \\cdot \\mathbf{B}_t = \\gamma \\cdot (\\mathbf{y} - \\mathbf{o})^T \\cdot \\mathbf{W}^{(o)}_{t-1} \\cdot \\mathbf{B}^{-1}_t \\cdot \\mathbf{B}_t = \\gamma \\cdot (\\mathbf{y} - \\mathbf{o})^T \\cdot \\mathbf{W}^{(o)}_{t-1}$ 其中第 $j$ 个元素为 $\\gamma \\cdot \\sum^c_{i=1}[(y_i - o_i)w^{(o)}_{i,j}]$。因此，$\\mathbf{D}^{(h)}$ 的第 $(j，k)$ 个元素是 $d^{(1)}_{j,k} \\cdot d^{(2)}_j = y_jx_k \\sum^c_{i=1}[(y_j - o_i)w^{(o)}_{i,j}]$，它是 $d^{(h)}_{j,k} = \\frac{\\partial E}{\\partial w^{(h)}_{j,k}}$ 的整数形式。 当前迭代中的梯度 ${\\mathbf{G}^{(h)}, \\mathbf{G}^{(o)} }$ 是由所有导数矩阵的集合计算的。 一旦达到最大迭代次数，训练协议将被终止，训练好的神经网络模型 $\\Theta_r$ 由 ${\\mathbf{W}^{(h)}_r, \\mathbf{W}^{(o)}_r }$ 组成。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:6:3","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Papers"],"content":"截断误差 如数据加密的章节所述，在 $\\mathbb{Z}_n$ 中，浮点数和整数之间的转换是通过使用预先确定的公共数 $l$ 来实现的。乘/除以 $l$ 的次数由 $\\mathbb{Z}_n$ 中的乘法次数决定。用一个简单的例子来说明这种情况：设 $Y$ 是两个整数 $X_1$ 和 $X_2$ 的乘积，每个整数是浮点数的 $l$ 倍。要将 $Y$ 恢复为浮点数，应选择 $l^2$ 作为除数。这一规则使得在本文的协议中可以转换为整数的最小值不小于 $l^{-1}$。设浮点数的精度为 $\\alpha$ 位。只要 $2^{\\alpha} / l \u003c 1$，转换就可以尽可能多地保留浮点数的有效位。 因此，唯一额外的误差源是算法3中浮点乘法之后的 $\\mathbf{v}$ 转换。在这样的转换中，由于减小了模数大小，$l$ 只使用了一次，这可能会引入截断错误。本文的截断操作的实际效果如第7节所示。 ","date":"2020-11-11","objectID":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/:6:4","tags":["MPC","PPML"],"title":"论文笔记：NPMML - A Framework for Non-interactive Privacy-preserving Multi-party Machine Learning","uri":"/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-npmml-a-framework-for-non-interactive-privacy-preserving-multi-party-machine-learning/"},{"categories":["Env"],"content":"Zotero的存储空间只有100M，不付费的话使用起来肯定不够。因此可以使用坚果云来同步附件，这样做的好处是ios上的PaperShip也可以通过WebDAV读取资料。 准备工作 注册一个坚果云账号，然后开启第三方应用管理： 登陆坚果云网页端，点击右上角的账号名称——账户信息——安全选项 然后点击添加应用，应用名称填Zotero(也可以填其它，只要你记得对应的软件)，会自动生成一个应用密码。 打开Zotero，点击菜单栏的编辑——首选项——同步，在文件同步中选择WebDav，复制坚果云内第三方应用管理的服务器地址、账户和密码，复制完成后点击 验证服务器。 这一步出现问题的话可以尝试在坚果云网页端手动建立一个zotero根目录，与zotero填的地址对应。 ZotFile的安装与设置 进入zotfile官网 下载。 然后打开Zotero，点击菜单栏工具——插件，有以下界面： 点击右上角的齿轮，选择 Install Add-on From File…，在弹出的插件安装中选择刚才下载的xpi文件进行安装。 安装完成后点击菜单栏工具——ZotFile Preferences——General Settings： 将Source Folder for Attaching new Files中的目录设置为浏览器默认的下载文件目录； 将Location of Files中的目录设置为第一个Attach stored copy of files，要选择这个才能与前面的WebDAV设置配合使用。 下面的 /%w/%y 是命名格式，也可以设置成别的。 完成以上操作后，当我们在浏览器中点击Zotero插件时，软件就会自动将下载下来的pdf文件拷贝到云盘的目录中，并将它的目录链接保存到对应的文献条目下。 PaperShip使用 方法类似上面，只要在坚果云网页端添加应用，在PaperShip登陆时选择WebDAV，把账号密码输入即可。这样在PC端管理的文献就可以方便地在移动端进行访问。 效果： ","date":"2020-07-10","objectID":"/zotero%E7%9A%84%E9%99%84%E4%BB%B6%E5%90%8C%E6%AD%A5/:0:0","tags":["Zotero","坚果云","PaperShip"],"title":"Zotero的附件同步","uri":"/zotero%E7%9A%84%E9%99%84%E4%BB%B6%E5%90%8C%E6%AD%A5/"},{"categories":["Study"],"content":"共享语义 不同的论文可能设置不太一样，这里2PC我参考的是SecureML中的设置，3PC参考的是ABY3和ASTRA中的设置。即对于一个数 $x$ 的算术共享，2PC的情况是将其拆成两份 $x_0$ 和 $x_1$，它们的和为 $x$，两方各拥有一份；3PC的情况是将其拆成三份 $x_0, x_1, x_2$，三方各拥有其中的两份，例如 $P_0$ 有 $(x_0, x_2)$，任意两方即可重构出 $x$。 布尔共享是各份额二进制表示的每一位异或等于原秘密 $x$ 的对应位。 加法 2PC和3PC下算术共享的加法是一样的，都只需要在本地将对应数的份额相加，不需要交互。 乘法 ","date":"2020-06-19","objectID":"/ppml%E4%B8%AD%E7%9A%842pc%E5%AF%B9%E6%AF%943pc/:0:0","tags":["MPC","密码学","PPML","Secret Sharing"],"title":"PPML中的2PC对比3PC","uri":"/ppml%E4%B8%AD%E7%9A%842pc%E5%AF%B9%E6%AF%943pc/"},{"categories":["Study"],"content":"2PC 乘法则有比较大的区别，首先是2PC，计算乘法 $ab = c$ 需要生成额外的乘法三元组 $(u,v,z)$ 满足 $z = uv$，这个三元组中的每个数也是在两方间加法共享的。 首先两方交互计算 $e = a-u$ 和 $f = b - v$，然后 $P_i$ 将结果 $c = ab$ 的份额设为 $c_i = -ief+a_if+eb_i+z_i$，其中 $i \\in {0,1}$。 ","date":"2020-06-19","objectID":"/ppml%E4%B8%AD%E7%9A%842pc%E5%AF%B9%E6%AF%943pc/:1:0","tags":["MPC","密码学","PPML","Secret Sharing"],"title":"PPML中的2PC对比3PC","uri":"/ppml%E4%B8%AD%E7%9A%842pc%E5%AF%B9%E6%AF%943pc/"},{"categories":["Study"],"content":"3PC 接下来是3PC，由于重复共享的设置（各方拥有三个份额中的两个），计算乘法时几乎不需要交互。计算 $x,y$ 两个数的积 $xy = z$ 时，观察到 $$\\begin{align}\rxy \u0026= (x_0 + x_1 + x_2)(y_0 + y_1 + y_2) \\\\\r\u0026= x_0y_0 + x_0y_1 + x_0y_2 \\\\\r\u0026+ x_1y_0 + x_1y_1 + x_1y_2 \\\\\r\u0026+ x_2y_0 + x_2y_1 + x_2y_2\r\\end{align}$$\r可以看到拆开的式子一共有九项，我们可以直接让 $P_i$ 各计算其中三项，令 $$z_0 = x_0y_0 + x_0y_2 + x_2y_0 \\\\\rz_1 = x_0y_1 + x_1y_0 + x_1y_1 \\\\\rz_2 = x_1y_2 + x_2y_1 + x_2y_2$$\r这时结果 $z$ 就以加法共享的方式在三方中共享，最后 $P_i$ 将自己的 $z_i$ 发送给 $P_{i+1}$（$i=2$ 时 $i+1 = 0$），$z$ 就重新在三方中重复共享了。 可以看到计算过程中只涉及本地操作，只有在生成重复共享时才需要三方各一次发送，效率比2PC要高。 比较 比较两个数 $u,v$ 的大小，等同于提取 $a = u-v$ 的 $\\text{msb}$，$u\u003ev \\rightarrow u-v\u003e0$ 时 $\\text{msb}(a) = 0$，反之 $\\text{msb}(a) = 1$。两方下没有给出具体的细节，SecureML中只提到使用乱码电路，这是一个比较昂贵的协议（将算术共享转换为布尔或姚共享也需要开销），而三方下的ASTRA中则利用了秘密共享方案的不对称性，下面的协议是基于 $\\text{sign}(r \\cdot a) = \\text{sign}(r) \\oplus \\text{sign}(a)$ 的事实： 首先在离线阶段，$P_1,P_2$ 共同选取两个随机数 $r, r' \\in \\Z_{2^l}$ 并设 $p = \\text{msb}(r)$，然后各方可以非交互式地设置 $p$ 的布尔共享 $⟦ p ⟧ ^{\\rm B}_{P_0} = (0,0)$, $⟦p⟧^{\\rm B}_{P_1} = (p,0)$ 以及 $⟦p⟧^{\\rm B}_{P_2} = (p,0)$。 到了在线阶段，$P_1$ 和 $P_2$ 设置它们对 $a$ 的份额，使得它们两方各自的份额之和为 $a$ ：$P_1$ 设 $[a]_{P_1} = x_0+x_1$ ，$P_2$ 设 $[a]_{P_2}=x_2$。然后 $P_1$ 和 $P_2$ 利用离线阶段生成的随机数 $r'$ 对 $[ra]_{P_i}$ 进行盲化并发送给 $P_0$（由于 $P_0$ 知道 $x_2$，若不进行盲化则会暴露 $r$ 给 $P_0$），$P_0$ 重构 $ra$ 并设 $q = \\text{msb}(ra)$，然后生成 $q$ 在三方中的布尔共享。最后各方在本地计算 $⟦\\text{msb}(a)⟧^B = ⟦p⟧^B \\oplus ⟦q⟧^B$，此时 $a$ 的符号位在三方中是布尔共享的。 ","date":"2020-06-19","objectID":"/ppml%E4%B8%AD%E7%9A%842pc%E5%AF%B9%E6%AF%943pc/:2:0","tags":["MPC","密码学","PPML","Secret Sharing"],"title":"PPML中的2PC对比3PC","uri":"/ppml%E4%B8%AD%E7%9A%842pc%E5%AF%B9%E6%AF%943pc/"},{"categories":["Env"],"content":"you-get是基于Python开发的，实际它不只支持视频下载，还支持图片、音乐等。而且，只要视频的地址，一行代码即可。 安装you-get 安装you-get的方式有很多，下面三种择其一即可。 ","date":"2020-05-20","objectID":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/:0:0","tags":["Python"],"title":"使用you-get下载网址视频","uri":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/"},{"categories":["Env"],"content":"使用pip安装 $ pip3 install you-get ","date":"2020-05-20","objectID":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/:1:0","tags":["Python"],"title":"使用you-get下载网址视频","uri":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/"},{"categories":["Env"],"content":"Git克隆 $ git clone git://github.com/soimort/you-get.git 然后直接运行./setup.py即可 $ python3 setup.py install ","date":"2020-05-20","objectID":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/:2:0","tags":["Python"],"title":"使用you-get下载网址视频","uri":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/"},{"categories":["Env"],"content":"通过HomeBrew安装（Mac） $ brew install you-get 下载视频 命令行中输入以下代码下载视频： $ you-get '视频地址URL' 这里以B站某视频为例： 下载好的视频存放在系统盘的用户目录下。 查看视频信息 命令行输入： $ you-get -i '视频地址URL' 用刚刚下载的视频测试，结果如下： 可以看到它的默认设置不是MP4格式的视频，如果想要换成这种格式，可以在命令行输入： $ you-get --itag=18 '视频地址URL' 支持的网站 除了B站，还可以用you-get下载国内外很多主流网站的视频、图片和音乐。 这里列出支持的国外网站： ","date":"2020-05-20","objectID":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/:3:0","tags":["Python"],"title":"使用you-get下载网址视频","uri":"/%E4%BD%BF%E7%94%A8you-get%E4%B8%8B%E8%BD%BD%E7%BD%91%E5%9D%80%E8%A7%86%E9%A2%91/"},{"categories":["Env"],"content":"图片来源：https://blog.csdn.net/caiandyong/article/details/53351737 希腊字母、数学构造、定界符、大型运算符以及标准函数名 二元运算、关系符 箭头符号、各种符号以及数学模式重音符 数列环境、其它风格的字体以及字体大小 ","date":"2020-04-26","objectID":"/latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/:0:0","tags":["LaTeX"],"title":"LaTeX常用符号表示方法","uri":"/latex%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/"},{"categories":["Study"],"content":" 设S有一个秘密，想以1/2的概率传递给R，即B有50%的机会收到这个秘密，另外50%的机会什么也没有收到，协议执行完后，B知道自己是否收到了这个秘密，但S却不知道R是否收到了这个秘密。这种协议就称为不经意传输协议。 ​ 例如A是机密的出售者，S列举了很多问题，意欲出售各个问题的答案，R想买其中一个问题的答案，但又不想让A知道自己买的是哪个问题的答案。 ","date":"2020-04-25","objectID":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/:0:0","tags":["密码学","MPC"],"title":"不经意传输（Oblivious Transfer）","uri":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/"},{"categories":["Study"],"content":"1-out-of-2 OT OT最早在1981年被 Michael O. Rabin提出，在Rabin的OT协议中，发送者S发送一个信息m给接收者R，接收者R以1/2的概率接受信息m。所以在协议交互的结束的时候，S并不知道R是否接受了消息。该方案是基于RSA加密体系构造的。 1985年S. Even, O. Goldreich, and A. Lempel提出了1-out-2 OT,在新的方案中S每次发送2个信息 $m_0$ 和 $m_1$，而R每次输入一个选择 $b$。当协议结束的时候，S无法获得关于 $b$ 的任何有价值的信息，而R只能获得 $m_b$ ，对于 $m_{1-b}$ ，R也一无所知。 ","date":"2020-04-25","objectID":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/:1:0","tags":["密码学","MPC"],"title":"不经意传输（Oblivious Transfer）","uri":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/"},{"categories":["Study"],"content":"协议 S要传送两条信息，不妨设为两个比特 $b_0$ 和 $b_1$，而R只能选择接受其中一个比特 $b_{\\theta}$。协议要保证S和R的安全，即： S不能知道任何关于 $\\theta$ 的信息； R不能知道任何关于 $b_{1-\\theta}$ 的信息。 为了达成上面两点要求，构造如下协议： S选择好两个比特信息 $b_0$ 和 $b_1$； S运行密钥生成算法（例如RSA）生成公私钥对（$sk,pk$）； S保密私钥，同时S要生成两个随机数 $x_0$ 和 $x_1$，并将这两个随机数和公钥一并传送给R； R选择 $\\theta$，并生成一个数 $r$，R用S的公钥加密 $r$，并生成信息 ​ $$v =x_{\\theta}+E_{pk}(r)$$ S在接收到 $v$ 之后，进行如下计算： ​ $r_{0}=D_{s k}\\left(v-x_{0}\\right)$ ​ $r_{1}=D_{s k}\\left(v-x_{1}\\right)$ S进行如下计算： ​ $b_{0}^{\\prime}=b_{0}+r_{0}$ ​ $b_{1}^{\\prime}=b_{1}+r_{1}$ 并将 $b'_0$ 和 $b'_1$ 传送给R； 接收到 $b'_0$ 和 $b'_1$ 后，R进行如下计算： ​ $b_\\theta = b'_\\theta - r$ ","date":"2020-04-25","objectID":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/:2:0","tags":["密码学","MPC"],"title":"不经意传输（Oblivious Transfer）","uri":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/"},{"categories":["Study"],"content":"正确性 进行如下推导： ​ $b_{\\theta}^{\\prime}-r=b_{\\theta}+r_{\\theta}-r=b_{\\theta}+D_{s k}\\left(v-x_{\\theta}\\right)-r$ 而 ​ $D_{s k}(v-x_\\theta)=D_{s k}\\left(x_\\theta+E_{p k}(r)-x_{\\theta}\\right)=D_{s k}\\left(E_{p k}(r)\\right)=r$ 因此可得 ​ $b'\\theta - r = b\\theta$ ","date":"2020-04-25","objectID":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/:2:1","tags":["密码学","MPC"],"title":"不经意传输（Oblivious Transfer）","uri":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/"},{"categories":["Study"],"content":"对于S的安全性 对于S来说，它的安全性要求R不能推断出 $b_{1-\\theta}$。R得到 $b'_\\theta$ 和 $b'_{1-\\theta}$ 之后，由协议可知R可以正确计算 $b'_\\theta$ ，下面证明R不能计算出 $b_{1-\\theta}$。 ​ $b_{1-\\theta}^{\\prime}-r=b_{1-\\theta}+D_{s k}\\left(v-x_{\\theta}\\right)-r$ 而 ​ $D_{s k}\\left(v-x_{\\theta}\\right)=D_{s k}\\left(x_{1-\\theta}+E_{p k}(r)-x_{\\theta}\\right) \\neq r$ 而且根据加密的特性，$D_{s k}\\left(x_{1-\\theta}+E_{p k}(r)-x_{\\theta}\\right)-r$ 与随机数是不可区分的，所以 $b'_{1-\\theta}-r$ 与随机数是不可区分的。因此协议对S是安全的。 ","date":"2020-04-25","objectID":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/:2:2","tags":["密码学","MPC"],"title":"不经意传输（Oblivious Transfer）","uri":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/"},{"categories":["Study"],"content":"对于R的安全性 R的安全性要求S不能获得关于 $\\theta$ 任何有价值的信息。 因为 $r$ 是随机数，所以 $E_{pk}(r)$ 与随机数是不可区分的。因此 $v$ 与随机数是不可区分的，所以S不能从 $v$ 获得关于 $\\theta$ 有价值的信息。 ","date":"2020-04-25","objectID":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/:2:3","tags":["密码学","MPC"],"title":"不经意传输（Oblivious Transfer）","uri":"/%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93oblivious-transfer/"},{"categories":["Env"],"content":"解决乱码+修改字体(微软雅黑) 下载微软雅黑字体,msyh.ttc ","date":"2020-04-24","objectID":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/:0:0","tags":["Ubuntu","Linux"],"title":"解决Ubuntu deepin-wine微信字体乱码","uri":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/"},{"categories":["Env"],"content":"添加字体 $ cp msyh.ttc ~/.deepinwine/Deepin-WeChat/drive_c/windows/Fonts ","date":"2020-04-24","objectID":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/:1:0","tags":["Ubuntu","Linux"],"title":"解决Ubuntu deepin-wine微信字体乱码","uri":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/"},{"categories":["Env"],"content":"修改系统注册表 $ gedit ~/.deepinwine/Deepin-WeChat/system.reg 修改以下两行 \"MS Shell Dlg\"=\"msyh\" \"MS Shell Dlg 2\"=\"msyh\" ","date":"2020-04-24","objectID":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/:2:0","tags":["Ubuntu","Linux"],"title":"解决Ubuntu deepin-wine微信字体乱码","uri":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/"},{"categories":["Env"],"content":"字体注册 $ gedit msyh_config.reg 内容添加 REGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] \"Lucida Sans Unicode\"=\"msyh.ttc\" \"Microsoft Sans Serif\"=\"msyh.ttc\" \"MS Sans Serif\"=\"msyh.ttc\" \"Tahoma\"=\"msyh.ttc\" \"Tahoma Bold\"=\"msyhbd.ttc\" \"msyh\"=\"msyh.ttc\" \"Arial\"=\"msyh.ttc\" \"Arial Black\"=\"msyh.ttc\" #注册 WINEPREFIX=~/.deepinwine/Deepin-WeChat deepin-wine regedit msyh_config.reg ","date":"2020-04-24","objectID":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/:3:0","tags":["Ubuntu","Linux"],"title":"解决Ubuntu deepin-wine微信字体乱码","uri":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/"},{"categories":["Env"],"content":"Reboot ","date":"2020-04-24","objectID":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/:4:0","tags":["Ubuntu","Linux"],"title":"解决Ubuntu deepin-wine微信字体乱码","uri":"/%E8%A7%A3%E5%86%B3ubuntu-deepin-wine%E5%BE%AE%E4%BF%A1%E5%AD%97%E4%BD%93%E4%B9%B1%E7%A0%81/"},{"categories":["Papers"],"content":"https://www.ccf.org.cn/c/2019-04-25/663625.shtml ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:0:0","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"中国计算机学会推荐国际学术期刊（网络与信息安全） ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:1:0","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"A类 序号 刊物简称 刊物全称 出版社 网址 1 TDSC IEEE Transactions on Dependable and Secure Computing IEEE http://dblp.uni-trier.de/db/journals/tdsc/ 2 TIFS IEEE Transactions on Information Forensics and Security IEEE http://dblp.uni-trier.de/db/journals/tifs/ 3 Journal of Cryptology Springer http://dblp.uni-trier.de/db/journals/joc/ ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:1:1","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"B类 序号 刊物简称 刊物全称 出版社 网址 1 TOPS ACM Transactions on Privacy and Security ACM https://tops.acm.org/ 2 Computers \u0026 Security Elsevier http://dblp.uni-trier.de/db/journals/compsec/ 3 Designs, Codes and Cryptography Springer http://dblp.uni-trier.de/db/journals/dcc/ 4 JCS Journal of Computer Security IOS Press http://dblp.uni-trier.de/db/journals/jcs/ ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:1:2","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"C类 序号 刊物简称 刊物全称 出版社 网址 1 CLSR Computer Law and Security Review Elsevier http://www.journals.elsevier.com/computer-law-and-security-review/ 2 EURASIP Journal on Information Security Springer http://dblp.uni-trier.de/db/journals/ejisec/ 3 IET Information Security IET http://dblp.uni-trier.de/db/journals/iet-ifs/ 4 IMCS Information Management \u0026 Computer Security Emerald http://dblp.uni-trier.de/db/journals/imcs/ 5 IJICS International Journal of Information and Computer Security Inderscience http://dblp.uni-trier.de/db/journals/ijics/ 6 IJISP International Journal of Information Security and Privacy Idea Group Inc http://dblp.uni-trier.de/db/journals/ijisp/ 7 JISA Journal of Information Security and Application Elsevier https://dblp.uni-trier.de/db/journals/istr/ 8 SCN Security and Communication Networks Wiley http://dblp.uni-trier.de/db/journals/scn/ ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:1:3","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"中国计算机学会推荐国际学术会议（网络与信息安全） ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:2:0","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"A类 序号 会议简称 会议全称 出版社 网址 1 CCS ACM Conference on Computer and Communications Security ACM http://dblp.uni-trier.de/db/conf/ccs/ 2 EUROCRYPT European Cryptology Conference Springer http://dblp.uni-trier.de/db/conf/eurocrypt/ 3 S\u0026P IEEE Symposium on Security and Privacy IEEE http://dblp.uni-trier.de/db/conf/sp/ 4 CRYPTO International Cryptology Conference Springer http://dblp.uni-trier.de/db/conf/crypto/ 5 USENIX Security Usenix Security Symposium USENIX Association http://dblp.uni-trier.de/db/conf/uss/ ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:2:1","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"B类 序号 会议简称 会议全称 出版社 网址 1 ACSAC Annual Computer Security Applications Conference IEEE http://dblp.uni-trier.de/db/conf/acsac/ 2 ASIACRYPT Annual International Conference on the Theory and Application of Cryptology and Information Security Springer http://dblp.uni-trier.de/db/conf/asiacrypt/ 3 ESORICS European Symposium on Research in Computer Security Springer http://dblp.uni-trier.de/db/conf/esorics/ 4 FSE Fast Software Encryption Springer http://dblp.uni-trier.de/db/conf/fse/ 5 CSFW IEEE Computer Security Foundations Workshop IEEE http://dblp.uni-trier.de/db/conf/csfw/ 6 SRDS IEEE International Symposium on Reliable Distributed Systems IEEE http://dblp.uni-trier.de/db/conf/srds/ 7 CHES International Conference on Cryptographic Hardware and Embedded Systems Springer http://dblp.uni-trier.de/db/conf/ches/ 8 DSN International Conference on Dependable Systems and Networks IEEE/IFIP http://dblp.uni-trier.de/db/conf/dsn/ 9 RAID International Symposium on Recent Advances in Intrusion Detection Springer http://dblp.uni-trier.de/db/conf/raid/ 10 PKC International Workshop on Practice and Theory in Public Key Cryptography Springer http://dblp.uni-trier.de/db/conf/pkc/ 11 NDSS ISOC Network and Distributed System Security Symposium ISOC http://dblp.uni-trier.de/db/conf/ndss/ 12 TCC Theory of Cryptography Conference Springer http://dblp.uni-trier.de/db/conf/tcc/ ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:2:2","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":["Papers"],"content":"C类 序号 会议简称 会议全称 出版社 网址 1 WiSec ACM Conference on Security and Privacy in Wireless and Mobile Networks ACM http://dblp.uni-trier.de/db/conf/wisec/ 2 SACMAT ACM Symposium on Access Control Models and Technologies ACM http://dblp.uni-trier.de/db/conf/sacmat/ 3 DRM ACM Workshop on Digital Rights Management ACM http://dblp.uni-trier.de/db/conf/drm/ 4 IH\u0026MMSec ACM Workshop on Information Hiding and Multimedia Security ACM http://dblp.uni-trier.de/db/conf/ih/ 5 ACNS Applied Cryptography and Network Security Springer http://dblp.uni-trier.de/db/conf/acns/ 6 AsiaCCS Asia Conference on Computer and Communications Security ACM http://dblp.uni-trier.de/db/conf/ccs/ 7 ACISP Australasia Conference on Information Security and Privacy Springer http://dblp.uni-trier.de/db/conf/acisp/ 8 CT-RSA Cryptographer’s Track at RSA Conference Springer http://dblp.uni-trier.de/db/conf/ctrsa/ 9 DIMVA Detection of Intrusions and Malware \u0026 Vulnerability Assessment http://dblp.uni-trier.de/db/conf/dimva/ 10 DFRWS Digital Forensic Research Workshop Elsevier http://dblp.uni-trier.de/db/conf/dfrws/ 11 FC Financial Cryptography and Data Security Springer http://dblp.uni-trier.de/db/conf/fc/ 12 TrustCom IEEE International Conference on Trust, Security and Privacy in Computing and Communications IEEE http://dblp.uni-trier.de/db/conf/trustcom/ 13 SEC IFIP International Information Security Conference Springer http://dblp.uni-trier.de/db/conf/sec/ 14 IFIP WG 11.9 IFIP WG 11.9 International Conference on Digital Forensics Springer *http://www.ifip119.org/Conferences/ 15 ISC Information Security Conference Springer http://dblp.uni-trier.de/db/conf/isw/ 16 ICDF2C International Conference on Digital Forensics \u0026 Cyber Crime Springer http://dblp.uni-trier.de/db/conf/icdf2c/ 17 ICICS International Conference on Information and Communications Security Springer http://dblp.uni-trier.de/db/conf/icics/ 18 SecureComm International Conference on Security and Privacy in Communication Networks ACM http://dblp.uni-trier.de/db/conf/securecomm/ 19 NSPW New Security Paradigms Workshop ACM http://dblp.uni-trier.de/db/conf/nspw/ 20 PAM Passive and Active Measurement Conference Springer http://dblp.uni-trier.de/db/conf/pam/ 21 PETS Privacy Enhancing Technologies Symposium Springer http://dblp.uni-trier.de/db/conf/pet/ 22 SAC Selected Areas in Cryptography Springer http://dblp.uni-trier.de/db/conf/sacrypt/ 23 SOUPS Symposium On Usable Privacy and Security USENIX http://dblp.uni-trier.de/db/conf/soups/ 24 HotSec USENIX Workshop on Hot Topics in Security USENIX *http://www.usenix.org/events/ ","date":"2020-04-20","objectID":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/:2:3","tags":["密码学"],"title":"CCF推荐国际学术会议和期刊目录（网络与信息安全）","uri":"/ccf%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95%E7%BD%91%E7%BB%9C%E4%B8%8E%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"categories":null,"content":"Hugo, the world’s fastest framework for building websites","date":"2019-02-28","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows. Hugo makes use of a variety of open source projects including: https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages. Hugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases. Websites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider. Learn more and contribute on GitHub. ","date":"2019-02-28","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"}]